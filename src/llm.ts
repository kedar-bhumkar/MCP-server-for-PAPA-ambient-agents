import { GoogleGenerativeAI } from "@google/generative-ai";
import dotenv from "dotenv";

dotenv.config();

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY || "");

/**
 * Invokes Gemini 1.5 Flash to convert a user message into a SQL query.
 * @param userMessage The message from the user.
 * @param systemPrompt Instructions for the LLM.
 * @param tableStructure The SQL table structure.
 * @param outputFormat The expected output format.
 * @returns The generated SQL query.
 */
export async function generateSqlFromMessage(
  userMessage: string,
  
): Promise<string> { 
/**
 * Configuration for get_event_data tool.
 * These will be provided later as per user instructions.
 */
const SYSTEM_PROMPT = `"## Role
You are a **SQL expert**.

## Objective
Convert the user message into a **valid PostgreSQL query** by following the rules below **strictly**.

## Instructions

1. **Relevance Check**
   - If the user message is **not related** to the \`agent_output\` table, return an **empty string**.

2. **Agent Classification**
   - If the message **is related** to the \`agent_output\` table:
     - Categorize it based on the \`agent_name\` column.
     - Allowed values for \`agent_name\`:
       - \`calendar_agent\`
       - \`event_agent\`
       - \`ainews_agent\`
       - \`research_agent\`
       - \`investment_agent\`
       - \`expense_agent\`
       - \`scraper_agent\`

3. **Query Generation**
   - Generate a PostgreSQL query using:
     - The identified \`agent_name\`
     - \`status = 'success'\`
     - Any **time range** explicitly specified in the user message

4. **Time Range Handling**
   - If **no time range** is specified:
     - Summarize and return the **latest available data**.

5. **No Data Case**
   - If the query returns no results:
     - Return the message:  
       \`\`\`
       no data found
       \`\`\`

6. **Schema Compliance**
   - Ensure the query **strictly follows** the table schema structure.

## Output Requirements
- Output **only** the PostgreSQL query, an empty string, or \`no data found\` as required.
- Do not include explanations or additional text."`;

const SQL_TABLE_STRUCTURE = `-table_name: agent_output
-table_schema:  public.agent_output (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  agent_name text null,
  agent_response json null,
  status text null,
  user_id text null,
  constraint agent_output_pkey primary key (id)
) TABLESPACE pg_default;
- key column details
  a) agent_name - one of calendar_agent, event_agent, ainews_agent, research_agent, investment_agent, expense_agent, scraper_agent 
b) status - success, fail-nodata
`;
const OUTPUT_FORMAT = "Return only the SQL query, no explanation.";

  const prompt = `
${SYSTEM_PROMPT}

User message: ${userMessage}

SQL Table Structure:
${SQL_TABLE_STRUCTURE}

Output Format:
${OUTPUT_FORMAT}
`;

  console.log(`Prompt: ${prompt}`);
  let text = await getLLMResponse(prompt);
  // Clean up SQL if it's wrapped in markdown
  text = text.replace(/```sql/g, "").replace(/```/g, "").trim();
  return text;
}



async function getLLMResponse(
  prompt: string,
): Promise<string> {
  const model = genAI.getGenerativeModel({ model: "gemini-3-flash-preview" });
  
  const result = await model.generateContent(prompt);
  const response = await result.response;
  console.log(`LLM Response: ${response.text()}`);
  return response.text();
}

/**
 * Executes a query using Gemini's file search capability (RAG).
 * @param userMessage The task or question from the user.
 * @returns The response from the LLM after searching the files.
 */
export async function performFileSearch(userMessage: string): Promise<string> {
  // Use gemini-1.5-flash as it supports file search/grounding better in some regions
  // or gemini-3-flash-preview if that's what's being used.
  // The user's example looks like it's for Gemini 1.5.
  const model = genAI.getGenerativeModel({ 
    model: "gemini-3-pro-preview",
  });

  const prompt = `#Guidelines
 -Please execute the *Task* using file_search tool and return the results in structured JSON as specified below.
 -Include  citations (file references) and strictly follow the JSON output schema.
 - Only rely on the informtion returned by the file_search tool. Do not add any other information based on youe internal knowledge. Do not make up any information.
 -Provide a summary first (brief, plain text), then details.
 - Each sentence in the summary should have a citation (file reference) from the file_search tool.Any sumamry items not found in the file_search tool should be ignored.
 -Do not add extra newlines or escape characters or response starting with the keyword json.Sumamrize the entire response in a easy to read manner 
 - Do not rewrite the user's question. Pass it verbatim
 -Task: ${userMessage}`;
 console.log(`Prompt: ${prompt}`);
  try {
    // We use the REST API format for tools as the SDK types might not be updated for file_search yet
    const result = await model.generateContent({
      contents: [
        {
          role: "user",
          parts: [{ text: prompt }],
        },
      ],
      tools: [
        {
          // @ts-ignore - file_search might not be in the types yet
          file_search: {
            file_search_store_names: ["fileSearchStores/vsglobal-h5qnnpqeas6v"],
          },
        } as any,
      ],
    });

    const response = await result.response;

    return response.text();
  } catch (error: any) {
    console.error("Error in performFileSearch:", error);
    throw new Error(`Failed to perform file search: ${error.message}`);
  }
}
